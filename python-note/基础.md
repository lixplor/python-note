# Python基础(版本3)

* Python3也称为Python 3000, Py3k
* 3.x与2.x不兼容
* 是解释型, 交互式, 面向对象的语言


## 环境配置

* Mac OSX:
    - Python 2.7:
        - Mac OSX自带python2.7环境, 终端输入`python`会进入2.7版本
    - Python 3:
        - 使用homebrew安装: `brew install python3`
    - 验证安装:
        - `python -V`或`python3 -V`查看版本号
    - 如需配置环境变量, 可将`/usr/local/python3/bin`添加到PATH变量中

* IDE
    - [PyCharm](https://www.jetbrains.com/pycharm/)
    - IDLE


## 编程方式

### 交互式编程

* 执行`python3`就可以进入交互式编程界面

### 脚本式编程

* 指定文件的编码有2种方式
    - 在文件头指定: `# -*- coding: UTF-8 -*-`
    - 在编辑器中修改文件的编码
* 执行Python脚本的2种方式:
    * Python2: `python xxx.py`
    * Python3: `python3 xxx.py`


## 基础语法

### 注释

* 单行注释: `#注释内容`
* 多行注释: 用三个单引号`'''`或三个双引号`"""`括起来

```python
'''
多行
注释
'''

"""
多行
注释
"""
```

### 行和缩进

* Python使用缩进代表代码块, 缩进的空格数是可变的, 但同一个代码块的语句必须有相同的缩进空格数

### 空行

* 函数之间或类的方法之间用空行分隔, 表示一段新代码的开始
* 类和函数入口之间也用一行空行分隔, 突出函数入口的开始
* 空行与缩进不同, 空行不是Python语法的一部分, 不插入空行也不会出错. 但空行的作用在于分隔两段不同功能或含义的代码, 便于以后维护

### 多行语句

* 一般一行可以写完一条语句
* 如果语句很长需要分为多行, 则使用`\`反斜杠来连接多行
* 如果是在`[]`, `{}`, `()`中的多行语句, 不需要用反斜杠换行
* 一行也可以编写多条语句, 多条语句间使用`;`分号分隔

```python
total = item_one + \
        item_two + \
        item_three
```


### 标准数据类型

* Number: 数字
    - int: 整数.
        - Python3中也表示长整型, 没有Python2的Long
    - float: 浮点数
    - bool: 布尔, True为1, False为0
    - complex: 复数
* String: 字符串
    - 单引号和双引号都表示字符串
    - 三引号(`'''`或`"""`)可以指定一个多行字符串
    - 使用`\`可以转义
    - 在字符串前加`r`或`R`, 则转义字符不会被转义, 而是直接显示斜杠和字符, 如`r"this is a line with \n"`, 这里的`\n`不会换行, 而是直接显示
    - 在字符串前加`u`或`U`, 如`u"this is an unicode string"`, 表示该字符串是unicode字符串
    - 字符串不可变
    - 多个字符串可以直接拼接: `"this ""is ""a string"`会拼接为`"this is a string"`
    - 字符串截取的语法: `变量(开始索引:结束索引)`
        - 索引从左往右从0开始, 从右往左从-1开始
    - 字符串格式化
        - `%c`: 字符及其ASCII码
        - `%s`: 字符串
        - `%d`: 整数
        - `%u`: 无符号整数
        - `%o`: 无符号八进制数
        - `%x`: 十六进制数
        - `%X`: 无符号十六进制数(大写)
        - `%f`: 浮点数字, 可以指定小数点后的精度
        - `%e`: 用科学计数法格式化浮点数
        - `%E`: 同`%e`
        - `%g`: 是`%f`和`%e`的简写
        - `%G`: 是`%f`和`%E`的简写
        - `%p`: 用十六进制数格式化变量的地址
        - `*`: 定义宽度或者小数点精度
        - `-`: 左对齐
        - `+`: 在正数前面显示加号
        - `<sp>`: 正数前面显示空格
        - `#`: 八进制数前显示`0`, 十六进制前显示`0x`或`0X`
        - `0`: 在显示的数字前面填充`0`而不是默认的空格
        - `%`: `%%`可以输出一个`%`而不被认为是格式化符号
        - `(var)`: 映射变量(字典参数)
        - `m.n.`: m是显示最小总宽度, n是小数点后的位数
* List: 列表
    - 元素写在方括号`[]`之中, 元素用逗号`,`隔开
    - 格式: `list = [元素1, 元素2, ..., 元素n]`
    - List可以存放数字, 字符串, List等元素, 元素的类型可以不同
    - 元素的值可以改变
    - 元素值的操作:
        - 访问: `list[2]`
        - 修改: `list[2] = 10`
        - 删除: `del list[2]`
    - 可以通过索引获取元素
    - 可以通过索引截取子列表: `list[1:4]`
    - 可以通过`+`连接两个列表: `list1 + list2`
    - 可以通过`*`进行重复操作: `print(list * 2)`, 输出两次列表
* Tuple: 元组
    - 元素写在小括号`()`中, 元素用逗号`,`隔开
    - 格式:
        - `tuple = ('abc', 123, 2.3)`
        - 空元组: `tup1 = ()`
        - 只有一个元素的元组: `tup2 = (20, )`, 需要在第一个元素后添加一个逗号
    - 元素的操作:
        - 访问: `tup[2]`
        - 修改: `tup[2] = 10`
        - 删除: 元素不能删除, 但可以删除整个元组: `del tup`
    - 元素不能修改, 但元素可以是List, 所以可以通过List改变
    - 元素类型可以不同
    - 可以通过索引获取元素
    - 可以通过索引截取子列表: `tuple[1:4]`
    - 可以通过`+`拼接
* Sets: 集合
    - 元素无序不重复的序列
    - 可用`{}`大括号或`set()`函数创建集合
        - 注意: 创建空集合只能使用`set()`, 而不能使用大括号, 因为大括号是用来创建空字典的
    - 格式
        - `set = {1, 2, 3}`
        - `a = set('abcde')`
* Dictionary: 字典
    - 无序的键值对集合
    - 用`{}`大括号表示
    - 键必须使用不可变类型, 且在同一个字典中必须唯一
    - 格式:
        - `dict([('key1', 'value1'), ('key2', 'value2')])`
        - `dict(A=1, B=2)`
        - 创建空字典: `{}`
    - 元素的操作:
        - 访问: `dict['key']`
        - 修改: `dict['key'] = value`
        - 删除:
            - 删除元素: `del dict['key']`
            - 删除字典: `del dict`或`del dict`


### 数据类型转换

* 将数据类型作为函数名即可
    - `int(x)`: 将x转换为一个整数
    - `float(x)`: 将x转换为一个浮点数
    - `complex(real)`: 创建一个复数
    - `str(x)`: 将对象x转换为字符串
    - `repr(x)`: 将对象x转换为表达式字符串
    - `eval(str)`: 计算字符串中有效的Python语句, 并返回一个对象
    - `tuple(s)`: 将序列s转换为一个元组
    - `list(s)`: 将序列s转换为一个列表
    - `set(s)`: 转换为可变集合
    - `dict(d)`: 创建一个字典, d必须是一个序列元组
    - `frozenset(s)`: 转换为不可变集合
    - `chr(x)`: 将一个整数转换为一个字符
    - `unichr(x)`: 将一个整数转换为Unicode字符
    - `ord(x)`: 将一个字符转换为它的整数值
    - `hex(x)`: 将一个整数转换为一个十六进制字符串
    - `oct(x)`: 将一个整数转换为一个八进制字符串


### 变量

* Python中变量不需要声明, 变量就是变量, 没有类型
* 每个变量在使用前必须赋值, 变量赋值后才会被创建
* 允许给多个变量赋值:
    - `a = b = c = 1`
    - `a, b, c = 1, 2, "ok"`
* 变量作用域
    - python中, 变量的作用域取决于该变量在哪里赋值
    - 作用域分类
        - L: local, 局部作用域
        - E: enclosing, 闭包函数外的函数中
        - G: Global, 全局作用域
        - B: Built-in, 内建作用域
    - 作用域查找规则: L -> E -> G -> B
    - 只有模块(module), 类(class), 函数(def, lambda)才会引入新的作用域, 其他代码块不会引用新的作用域
* 全局变量
    - 定义在函数外的变量
    - 可以在整个程序范围内访问
* 局部变量
    - 定义在函数内的变量
    - 只能在函数内部访问
    - 可以使用`global`和`nonlocal`关键字将局部变量修改为外部作用域的变量
        - `global`: 修改为全局变量
        - `nonlocal`: 修改为外层作用域的变量

### 运算符

* 算术运算符
    - `+`: 加法
    - `-`: 减法
    - `*`: 乘法
    - `/`: 除法, 得到小数
    - `//`: 取整除法, 得到整数
    - `%`: 取余
    - `**`: 次方
* 比较运算符
    - `==`: 等于
    - `!=`: 不等
    - `>`: 大于
    - `>=`: 大于等于
    - `<`: 小于
    - `<=`: 小于等于
* 赋值运算符
    - `=`: 简单赋值运算符
    - `+=`: 加法赋值运算符
    - `-=`: 减法赋值运算符
    - `*=`: 乘法赋值运算符
    - `/=`: 除法赋值运算符
    - `//=`: 取整除法运算符
    - `%=`: 取余赋值运算符
    - `**=`: 幂赋值运算符
* 位运算符
    - `&`: 按位与
    - `|`: 按位或
    - `^`: 按位异或
    - `~`: 按位取反
    - `<<`: 左移
    - `>>`: 右移
* 逻辑运算符
    - `and`: 与
    - `or`: 或
    - `not`: 非
* 成员运算符
    - `in`: 在序列中找到值则返回true, 否则false
    - `not in`: 在序列中找不到值则返回true, 否则false
* 身份运算符
    - `is`: 判断两个变量是否引自同一个对象, 是则true, 否则false
    - `not is`: 判断两个变量是否引自同一个对象, 是则false, 否则true
* 运算符优先级

|运算符|描述|
|-----|---|
|`**`|指数 (最高优先级)|
|`~`, `+`, `-`|按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)|
|`*`, `/`, `%`, `//`|乘, 除, 取模和取整除|
|`+`, `-`|加法减法|
|`>>`, `<<`|右移, 左移运算符|
|`&`|位 'AND'|
|`^`, `|`|位运算符|
|`<=`, `<`, `>`, `>=`|比较运算符|
|`<>`, `==`, `!=`|等于运算符|
|`=`, `%=`, `/=`, `//=`, `-=`, `+=`, `*=`, `**=`|赋值运算符|
|`is`, `is not`|身份运算符|
|`in`, `not in`|成员运算符|
|`not`, `or`, `and`|逻辑运算符|


### 条件判断

* if
    - 注意冒号和缩进

```python
if 条件:
    代码块
elif 条件:
    代码块
else:
    代码块
```

### 循环语句

* while循环
    - 注意冒号和缩进
* for循环
    - 注意冒号和缩进
    - else: 当没有执行循环时执行, 可以省略
* break: 终止循环
* continue: 结束本次, 继续下次循环
* pass: 为了保持结构完整的空语句, 不做任何事, 一般用于占位

```python
# while循环
while 判断条件:
    语句

# for循环
for 变量 in 序列:
    语句
else:
    语句
```


### 迭代器和生成器

* 迭代器
    - 遍历集合, 只能往前不会后退
    - 2个基本方法
        - `iter(集合)`: 创建迭代器对象
        - `next(迭代器对象)`: 输出迭代器的下一个元素
    - 迭代器可以使用for遍历: `for x in iterator:`
* 生成器
    - 使用了yield的函数被称为生成器
    - 生成器是一个返回迭代器的函数, 只能用于迭代操作
    - 在调用生成器运行的过程中, 每次遇到yield时函数会暂停并保存当前所有的运行信息, 返回yield的值, 并在下一次执行next()方法时从当前位置继续执行


### 函数

* 定义函数
    - 格式:
        - 使用关键字`def`, 后接函数名和参数列表, 冒号
        - 函数内第一行可以使用字符串定义一个函数说明
        - 函数体要缩进
        - `return 表达式`可以结束函数并返回值, 如果不带表达式, 则返回None
* 参数
    - python中类型属于对象, 变量是没有类型的
    - python中分为可变对象和不可变对象
        - 不可变对象: `string`, `tuple`, 数字
            - 如`a = 5`, 然后`a = 10`, 相当于新生成了一个int对象10, 将5丢弃, 让a指向10. 而不是改变a的值, 而是相当于新生成了a
        - 可变对象: `list`, `dict`
            - 修改集合元素, 则是修改其内部的值, 而对象本身没有改变
    - 参数传递
        - 对于不可变类型: 类似于值传递. 传递的是a的值, 不影响a对象本身
        - 对于可变类型: 类似于引用传递. 传递的是a的引用, 修改a会影响a对象本身
    - 参数分类
        - 必须参数
            - 必须以正确的顺序传入参数
        - 关键字参数
            - 允许调用时参数的顺序与声明不一致
            - 如:
                - 函数定义: `def print(str, num):`
                - 调用: `print(num = 1, str = "hi")`
        - 默认参数
            - 如果没有传递参数, 则会使用默认值
            - 默认参数必须放在参数列表最后
            - 如:
                - 函数定义: `def print(name, age = 35):`
                - 调用: `print("li")`
        - 不定长参数
            - 调用时传入的参数的数量可变, 从0到多个
            - 给形参变量名加`*`就可以指定为不定长参数
            - 本质上是一个元组
            - 如:
                - 函数定义: `def print(name, *args)`
                - 调用: `print("hi", 1, 2, 3)`
* 匿名函数
    - 匿名表示不需要def来定义函数
    - 使用lambda来创建匿名函数
        - lambda是一个表达式, 而不是代码块
        - lambda拥有自己的命名空间, 不能访问自有参数列表之外或全局命名空间中的参数
    - 格式: `lambda 参数列表: 函数体;`
        - 如: `sum = lambda a, b: a + b;`

```python
# 定义函数格式
def 函数名(参数列表):
    函数体


# 示例
def hello():
    print("Hello World!")

hello()

def area(width, height):
    return width * height;

a = area(1, 2)
```


### 模块

* 模块是一个包含c定义的函数和变量的文件, 后缀名为`.py`
* 模块可以被别的程序引入, 使用该模块中的函数
* 导入模块
    - `import`: 将整个模块导入
        - 如: `import somemodule`
    - `from ... import`: 从某个模块中导入一个或多个具体的函数
        - 如:
            - `from somemodule import somefunction`
            - `from somemodule import firstfunc, secondfunc, thirdfunc`
            - `from somemodule import *`
* `__name__`属性
    - 当一个模块被另一个程序第一次引入时, 主程序将运行, 如果想在模块引入时不执行模块中的某一行程序, 则可以用`__name__`属性来使该程序块仅在自身运行时执行
    - 判断方式: `if __name__ == '__main__': # 在自身运行, 否则在另一模块中运行`


### 键盘录入和屏幕输出

* `input()`: 获取键盘输入
* 输出
    - `print()`: 屏幕输出, 默认是换行的
        - 如果不想换行, 则要在变量末尾加上`end=""`
    - `str()`: 返回一个用户易读的表达形式
    - `字符串.format(参数)`: 格式化字符串
        - 示例: `'{name}网址:{site}'.format(name='百度', site='www.baidu.com')`
    - `repr()`: 产生一个解释器易读的表达式

```python
num = input("please input a num:")
# 换行输出
print(num)
# 不换行输出
print(num, end="")
```


### 文件读写

* `file open(filename, mode)`: 以指定模式打开文件, 并返回一个file对象
    - finename: 文件名字符串
    - mode: 模式
        - `r`: 只读
        - `rb`: 以二进制格式打开一个文件, 用于只读. 文件指针放在文件开头
        - `r+`:打开一个文件用于读写. 文件指针放在文件开头
        - `rb+`: 以二进制格式打开一个文件用于读写. 文件指针放在文件开头
        - `w`: 打开一个文件只用于写入. 如果该文件已存在, 则将其覆盖. 如果不存在, 则创建新文件
        - `wb`: 以二进制格式打开一个文件只用于写入. 如果该文件已存在, 则将其覆盖. 如果不存在, 则创建新文件
        - `w+`: 打开一个文件用于读写, 如果该文件已存在, 则将其覆盖. 如果不存在, 则创建新文件
        - `wb+`: 以二进制格式打开一个文件用于读写. 如果该文件已存在, 则将其覆盖. 如果不存在, 则创建新文件
        - `a`: 打开一个文件用于追加. 如果该文件已存在, 文件指针将会放在文件的结尾. 新的内容会被写入到已有内容之后. 如果文件不存在, 则创建新文件
        - `ab`: 以二进制格式打开一个文件用于追加. 如果该文件已存在, 文件指针将会放在文件结尾. 新的内容会被写入到已有内容之后. 如果文件不存在, 则创建新文件
        - `a+`: 打开一个文件用于读写. 如果该文件已存在, 文件指针将会放在文件的末尾. 文件打开时会是追加模式. 如果文件不存在, 则创建新文件
        - `ab+`: 以二进制格式打开一个文件用于追加. 如果该文件已存在, 文件指针将会放在文件的结尾. 如果该文件不存在, 则创建新文件
* `read()`: 读取文件内容, 返回字符串或字节对象
* `read(size)`: 读取指定长度的文件内容, 返回字符串或字节对象
* `readline()`: 读取一行. 当读到末尾时返回空字符串
* `readlines()`: 返回文件中包含的所有行
* `write(string)`: 写入字符串到文件中, 返回写入的字符数
* `tell()`: 返回文件对象当前所处的位置, 从文件开头开始算起的字节数
* `seek(offset, from_what)`: 指定文件的位置
    - offset: 相对于指定位置偏移的字符量
    - from_what: 0表示开头; 1表示当前位置; 2表示文件结尾
* `close()`: 关闭文件. 关闭后文件不能再进行读写
* `flush()`: 将缓冲区中的数据写入文件
* `isatty()`: 如果文件链接到一个终端设备, 返回true, 否则false
* `next()`: 返回文件下一行
* `truncate(size)`: 从文件首行首字符开始截断, 截断文件为size个字符, 无size表示从当前位置截断


### OS操作

* os模块
    - `access(path, mode)`: 验证权限模式
    - `chdir(path)`: 改变当前工作目录
    - `chflags(path, flags)`: 设置路径的编辑为数字标记
    - `chmod(path, mode)`: 修改权限
    - `chown(path, uid, gid)`: 修改文件所有者
    - `chroot(path)`: 改变当前进程的根目录
    - `close(fd)`: 关闭文件描述符
    - `closerange(fd low, fd high)`: 关闭所有文件描述符
    - `dup(fd)`: 复制文件描述符
    - `dup2(fd, fd2)`: 将一个文件描述符复制到另一个文件描述符
    - `fchdir(fd)`: 通过文件描述符改变当前工作目录
    - `fchmode(fd, mode)`: 改变一个文件的访问权限
    - `fchown(fd, uid, gid)`: 修改一个文件的所有权, 这个函数修改一个文件的用户ID和用户组ID, 该文件由文件描述符fd指定
    - `fdatasync(fd)`: 强制将文件写入磁盘, 该文件由文件描述符fd指定, 但是不强制更新文件的状态信息.
    - `fdopen(fd[, mode[, bufsize]])`: 通过文件描述符 fd 创建一个文件对象, 并返回这个文件对象
    - `fpathconf(fd, name)`: 返回一个打开的文件的系统配置信息. name为检索的系统配置的值, 它也许是一个定义系统值的字符串, 这些名字在很多标准中指定(POSIX.1, Unix 95, Unix 98, 和其它).
    - `fstat(fd)`: 返回文件描述符fd的状态, 像stat().
    - `fstatvfs(fd)`: 返回包含文件描述符fd的文件的文件系统的信息, 像 statvfs()
    - `fsync(fd)`: 强制将文件描述符为fd的文件写入硬盘.
    - `ftruncate(fd, length)`: 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小.
    - `getcwd()`: 返回当前工作目录
    - `getcwdu()`: 返回一个当前工作目录的Unicode对象
    - `isatty(fd)`: 如果文件描述符fd是打开的, 同时与tty(-like)设备相连, 则返回true, 否则False.
    - `lchflags(path, flags)`: 设置路径的标记为数字标记, 类似 chflags(), 但是没有软链接
    - `lchmod(path, mode)`: 修改连接文件权限
    - `lchown(path, uid, gid)`: 更改文件所有者, 类似 chown, 但是不追踪链接.
    - `link(src, dst)`: 创建硬链接, 名为参数 dst, 指向参数 src
    - `listdir(path)`: 返回path指定的文件夹包含的文件或文件夹的名字的列表.
    - `lseek(fd, pos, how)`: 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; SEEK_END或者2则从文件尾部开始. 在unix, Windows中有效
    - `lstat(path)`: 像stat(),但是没有软链接
    - `major(device)`: 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field).
    - `makedev(major, minor)`: 以major和minor设备号组成一个原始设备号
    - `makedirs(path[, mode])`: 递归文件夹创建函数. 像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹.
    - `minor(device)`: 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field ).
    - `mkdir(path[, mode])`: 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制).
    - `mkfifo(path[, mode])`: 创建命名管道, mode 为数字, 默认为 0666 (八进制)
    - `mknod(filename[, mode=0600, device])`: 创建一个名为filename文件系统节点(文件, 设备特别文件或者命名pipe).
    - `open(file, flags[, mode])`: 打开一个文件, 并且设置需要的打开选项, mode参数是可选的
    - `openpty()`: 打开一个新的伪终端对. 返回 pty 和 tty的文件描述符.
    - `pathconf(path, name)`: 返回相关文件的系统配置信息.
    - `pipe()`: 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写
    - `popen(command[, mode[, bufsize]])`: 从一个 command 打开一个管道
    - `read(fd, n)`: 从文件描述符 fd 中读取最多 n 个字节, 返回包含读取字节的字符串, 文件描述符 fd对应文件已达到结尾, 返回一个空字符串.
    - `readlink(path)`: 返回软链接所指向的文件
    - `remove(path)`: 删除路径为path的文件. 如果path 是一个文件夹, 将抛出OSError; 查看下面的rmdir()删除一个 directory.
    - `removedirs(path)`: 递归删除目录.
    - `rename(src, dst)`: 重命名文件或目录, 从 src 到 dst
    - `renames(old, new)`: 递归地对目录进行更名, 也可以对文件进行更名.
    - `rmdir(path)`: 删除path指定的空目录, 如果目录非空, 则抛出一个OSError异常.
    - `stat(path)`: 获取path指定的路径的信息, 功能等同于C API中的stat()系统调用.
    - `stat_float_times([newvalue])`: 决定stat_result是否以float对象显示时间戳
    - `statvfs(path)`: 获取指定路径的文件系统统计信息
    - `symlink(src, dst)`: 创建一个软链接
    - `tcgetpgrp(fd)`: 返回与终端fd(一个由open()返回的打开的文件描述符)关联的进程组
    - `tcsetpgrp(fd, pg)`: 设置与终端fd(一个由open()返回的打开的文件描述符)关联的进程组为pg.
    - `tempnam([dir[, prefix]])`: 返回唯一的路径名用于创建临时文件.
    - `tmpfile()`: 返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口, 没有文件描述符, 将会自动删除.
    - `tmpnam()`: 为创建一个临时文件返回一个唯一的路径
    - `ttyname(fd)`: 返回一个字符串, 它表示与文件描述符fd 关联的终端设备. 如果fd 没有与终端设备关联, 则引发一个异常.
    - `unlink(path)`: 删除文件路径
    - `utime(path, times)`: 返回指定的path文件的访问和修改的时间.
    - `walk(top[, topdown=True[, onerror=None[, followlinks=False]]])`: 输出在文件夹中的文件名通过在树中游走, 向上或者向下.
    - `write(fd, str)`: 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度
